+коментарии через #


начало 
sector [сектор диска]
format [формат программы - winconsole,boot...]
initialize [компонент для инициализации]

импорт
пример:
import [название файла]
можно только импортировать файлы языка, которые были интерпретированы в fasm


работа с консолью

команды для компьютеров без операционной системы:
чтобы использовать эти функции импортируйте lib/sioc.asm
вывод:
bprint [переменная или текст],[длинна (указывать если печатаете переменную)]

ввод:
binputchr (можно введённый символ записать в переменную)
binput [переменная для буфера],[функция когда нажат enter]
очистка экрана:
bcleanscreen
установить цвет консоли:
btextcolor [цвет]
получение позиции курсора:
bgetcurpozx
bgetcurpozy
установка позиции курсора:
bsetcurpoz [x],[y]
установка размера курсора:
bsetcursize [первый пиксель],[второй пиксель]


команды для компьютеров с операционной системой Windows:
чтобы использовать эти функции импортируйте lib/scioc.asm
установка точки входа:
entrypoint [функция]
вывод:
сprint [переменная]
cprintarray [номер элемента массива]
ввод:
сinput (данные оставляет в переменой enteredTextcinput!)
команды windows:
csystem [переменная для команды]
секции:
section [название] [ключи, напимер readable,writeable и т.д.]
Сравнить строки:
cstrcmp [1 строка],[2 строка],[длинна строк],[строка для буфера],[функция если строки не равны] then [название функции]
Установить кодировку:
csetencoding [название кодировки]


фунции
синтасис:
func Test
{
 код
}

ret  - в конце, если надо возвратится в преведущюю функцию, если она была
ret [возвращаемые данные] - если надо вернуть данные после выполнения функции
stop - если надо остановится
ничего не ставить - если надо перейти на следующую функцию

в фунцию ничего не передаётся, потому что все переменные глобальные
чтобы вызвать функцию, надо просто написать её название
чтобы не вызвать, а передать управление функции (прыгнуть), - надо перед названием функции написать goto


структуры
синтасис:
struct Test
{
 данные
}

чтобы создать экземпляр структуры надо написать:
[имя структуры] [имя экземпляра структуры]

чтобы обращатся к данным в структуре надо написать:
[имя экземпляра структуры].[название переменной в структуре]


типы данных
byte - определяет один байт данных
word - определяет двухбайтовое слово (16 бит)
dword - определяет четырехбайтовое слово (32 бита)
qword - определяет восьмибайтовое слово (64 бита)
tword - определяет десятибайтовую последовательность (80 бит)
пример создания переменной:
byte [название переменной]=0
 


сохранение и востановление данных
пример:
save [название переменной или регистра]
код с изменением значения переменной или регистра
restore [название переменной или регистра]


указатели
чтобы указать ссылку на переменную надо написать в конце @:
variable = variable2@ 


преобразование типов данных
синтаксис:
в данном случает переменная var1 это dword, а var2 это byte
var1 = (dword)var2


действия с переменными
[название переменной]+=2 - плюс
[название переменной]-=2 - минус
[название переменной]*2 - умножение
[название переменной] =(или equ) 2 - равенство
[название переменной для остатка],[название переменной для суммы]/2 - деление
можно выполнять только одно действие за раз, из-за ограничений fasm'а
чтобы переменная была ничему не равна, после равно надо написать null


циклы
цикл loop работает как while, и как for в зависимости от написания:
если написать в конце функии loop inf то функция будет повторятся бесконечно
если написать в  loop [название переменной] то функция будет повторятся, пока переменная не будет равна -1 (после цикла значение переменной восстанавливается)
если написать в  loop [условие] то функция будет повторятся, пока условие будет правильным
также можно сравнивать возвращаемые данные из функции (функция будет вызвана)


массивы данных:
синтаксис:
[тип данных] [название массива] = [данные],[данные],[данные]...
добавление в массив:
например:
arrayadd [название массива],[индекс элемента],[сдвиг по байтам]
удаление из массива:
arraydelete [название массива],[индекс элемента],[сдвиг по байтам]


резервирование памяти под данные:
reserve [тип данных],[место]


if и else
синтаксис:
if a>b then [название функции]
else [название функции]

if работает также, как и в других языках
также можно сравнивать возвращаемые данные из функции (функция будет вызвана):
if a==[название функции] then [название функции]
для сравнения строк:
comparestr [указатель на первую строку],[указатель на вторую строку],[длинна строк],[функция если строки не равны] then [название функции]
можно ставить только одно условие за раз, из-за ограничений fasm'а


ассемблерные вставки 
синтаксис:
*asm_start
 ассемблерный код
*asm_end
